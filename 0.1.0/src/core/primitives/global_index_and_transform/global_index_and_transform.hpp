// mousse: CFD toolbox
// Copyright (C) 2011-2015 OpenFOAM Foundation
// Copyright (C) 2016 mousse project
// Class
//   mousse::globalIndexAndTransform
// Description
//   Determination and storage of the possible independent transforms
//   introduced by coupledPolyPatches, as well as all of the possible
//   permutations of these transforms generated by the presence of
//   multiple coupledPolyPatches, i.e. more than one cyclic boundary.
//   Also provides global index encoding and decoding for entity
//   (i.e. cell) index, processor index and transform index (0 or
//   positive integer) to a labelPair.
// SourceFiles
//   global_index_and_transform.cpp

#ifndef global_index_and_transform_hpp_
#define global_index_and_transform_hpp_

#include "label_pair.hpp"
#include "vector_tensor_transform.hpp"
#include "hash_set.hpp"
#include "pstream.hpp"
#include "poly_mesh.hpp"

namespace mousse
{
class polyMesh;
class globalIndexAndTransform
{
public:
  // Public classes
    //- Less function class used in sorting encoded transforms and indices
    //  Minimum of:
    //  - processor
    //  - local index
    //  - transform
    class less
    {
    public:
      inline bool operator()(const labelPair&, const labelPair&) const;
    };
private:
  // Private data
    //- Reference to mesh
    const polyMesh& mesh_;
    //- The possible independent (non-permuted) transforms of the
    //  geometry, i.e. for a geometry with two cyclics, this
    //  stores the two transforms, not the eight permutations.
    //  There may not be more than three transforms in the range
    //  of coupledPolyPatch geometries (separated XOR
    //  non-parallel) and symmetries (cuboid periodicity only)
    //  supported.
    List<vectorTensorTransform> transforms_;
    //- The permutations of the transforms, stored for lookup
    //  efficiency.  If there are n transforms, then there are
    //  (3^n) permutations, including the no-transformation
    //  transform.
    List<vectorTensorTransform> transformPermutations_;
    //- Index of identity transform.
    label nullTransformIndex_;
    //- Mapping from patch index to which transform it matches (or
    //  -1 for none) (.first()) and what sign to use for it,
    //  i.e. +/- 1 (.second()).
    List<Pair<label> > patchTransformSign_;
  // Private static data
    //- Number of spaces to reserve for transform encoding
    static const label base_;
  // Private Member Functions
    //- Determine all of the independent basic transforms of the
    //  geometry by analysing the coupledPolyPatches
    void determineTransforms();
    //- Generate all of the transformation permutations
    void determineTransformPermutations();
    //- Determine which patch uses which transform (if any) and which
    //- Sign to use
    void determinePatchTransformSign();
    //- Test a list of reference transforms to see if the test
    //  transform matches one.  Return +1 or -1 depending on the
    //  sign of the match, or 0 if none matches.
    label matchTransform
    (
      const List<vectorTensorTransform>& refTransforms,
      label& matchedRefTransformI,
      const vectorTensorTransform& testTransform,
      scalar tolerance,
      bool checkBothSigns
    ) const;
    //- Encode transform index. Hardcoded to 3 independent transforms max.
    inline label encodeTransformIndex
    (
      const FixedList<mousse::label, 3>& permutationIndices
    ) const;
    //- Decode transform index. Hardcoded to 3 independent transforms max.
    inline FixedList<label, 3> decodeTransformIndex
    (
      const label transformIndex
    ) const;
public:
    //- Declare friendship with the entry class for IO
    friend class globalPoints;
  // Declare name of the class and its debug switch
  CLASS_NAME("globalIndexAndTransform");
  // Constructors
    //- Construct from components
    globalIndexAndTransform(const polyMesh& mesh);
    //- Disallow default bitwise copy construct
    globalIndexAndTransform(const globalIndexAndTransform&) = delete;
    //- Disallow default bitwise assignment
    globalIndexAndTransform& operator=
    (
      const globalIndexAndTransform&
    ) = delete;
  //- Destructor
  ~globalIndexAndTransform();
  // Member Functions
    //- Generate a transform index from the permutation indices of
    //  the independent transforms.  Permutations indices must
    //  only be -1, 0 or +1.
    inline label encodeTransformIndex
    (
      const List<label>& permutationIndices
    ) const;
    //- Add patch transformation to transformIndex. Return new
    //  transformIndex. (by default the patch is the sending, not the
    //  receiving, patch)
    inline label addToTransformIndex
    (
      const label transformIndex,
      const label patchI,
      const bool isSendingSide = true,
      const scalar tol = SMALL
    ) const;
    //- Combine two transformIndices
    inline label mergeTransformIndex
    (
      const label transformIndex0,
      const label transformIndex1
    ) const;
    //- Combine two transformIndices
    inline label minimumTransformIndex
    (
      const label transformIndex0,
      const label transformIndex1
    ) const;
    //- Subtract two transformIndices
    inline label subtractTransformIndex
    (
      const label transformIndex0,
      const label transformIndex1
    ) const;
    //- Encode index and bare index as components on own processor
    inline static labelPair encode
    (
      const label index,
      const label transformIndex
    );
    //- Encode index and bare index as components on given processor
    inline static labelPair encode
    (
      const label procI,
      const label index,
      const label transformIndex
    );
    //- Index carried by the object
    inline static label index(const labelPair& globalIAndTransform);
    //- Which processor does this come from?
    inline static label processor(const labelPair& globalIAndTransform);
    //- Transform carried by the object
    inline static label transformIndex
    (
      const labelPair& globalIAndTransform
    );
    // Access
      //- Return the number of independent transforms
      inline label nIndependentTransforms() const;
      //- Return access to the stored independent transforms
      inline const List<vectorTensorTransform>& transforms() const;
      //- Return access to the permuted transforms
      inline const List<vectorTensorTransform>&
      transformPermutations() const;
      //- Return the transformIndex (index in transformPermutations)
      //  of the identity transform
      inline label nullTransformIndex() const;
      //- Return access to the per-patch transform-sign pairs
      inline const List<Pair<label> >& patchTransformSign() const;
      //- Access the overall (permuted) transform corresponding
      //  to the transformIndex
      inline const vectorTensorTransform& transform
      (
        label transformIndex
      ) const;
      //- Access the all of the indices of the transform
      //  permutations corresponding the transforms of the
      //  listed patch indices
      inline labelList transformIndicesForPatches
      (
        const labelHashSet& patchIs
      ) const;
      //- Apply all of the transform permutations
      //  corresponding the transforms of the listed patch
      //  indices to the supplied point
      inline pointField transformPatches
      (
        const labelHashSet& patchIs,
        const point& pt
      ) const;
};
}  // namespace mousse
// #include "global_index_and_transform_i.hpp"
// Member Functions
bool mousse::globalIndexAndTransform::less::operator()
(
  const labelPair& a,
  const labelPair& b
) const
{
  label procA = globalIndexAndTransform::processor(a);
  label procB = globalIndexAndTransform::processor(b);
  if (procA < procB)
  {
    return true;
  }
  else if (procA > procB)
  {
    return false;
  }
  else
  {
    // Equal proc.
    label indexA = globalIndexAndTransform::index(a);
    label indexB = globalIndexAndTransform::index(b);
    if (indexA < indexB)
    {
      return true;
    }
    else if (indexA > indexB)
    {
      return false;
    }
    else
    {
      // Equal index
      label transformA = globalIndexAndTransform::transformIndex(a);
      label transformB = globalIndexAndTransform::transformIndex(b);
      return transformA < transformB;
    }
  }
}
mousse::label mousse::globalIndexAndTransform::encodeTransformIndex
(
  const List<label>& permutationIndices
) const
{
  if (permutationIndices.size() != transforms_.size())
  {
    FATAL_ERROR_IN
    (
      "mousse::label encodeTransformIndex"
      "("
        "const List<label>& permutationIndices,"
      ") const"
    )
    << "permutationIndices " << permutationIndices
    << "are of a different size to the number of independent transforms"
    << abort(FatalError);
  }
  label transformIndex = 0;
  label w = 1;
  FOR_ALL(transforms_, b)
  {
    if (mag(permutationIndices[b]) > 1)
    {
      FATAL_ERROR_IN
      (
        "mousse::label encodeTransformIndex"
        "("
        "const List<label>& permutationIndices,"
        ") const"
      )
      << "permutationIndices " << permutationIndices
      << "are illegal, they must all be only -1, 0 or +1"
      << abort(FatalError);
    }
    transformIndex += (permutationIndices[b] + 1)*w;
    w *= 3;
  }
  return transformIndex;
}
mousse::label mousse::globalIndexAndTransform::encodeTransformIndex
(
  const FixedList<mousse::label, 3>& permutation
) const
{
  if (nIndependentTransforms() == 0)
  {
    return 0;
  }
  if (nIndependentTransforms() == 1)
  {
    return permutation[0]+1;
  }
  else if (nIndependentTransforms() == 2)
  {
    return (permutation[1]+1)*3 + (permutation[0]+1);
  }
  else
  {
    return
      (permutation[2]+1)*9
      + (permutation[1]+1)*3
      + (permutation[0]+1);
  }
}
mousse::FixedList<mousse::label, 3>
mousse::globalIndexAndTransform::decodeTransformIndex
(
  const label transformIndex
) const
{
  FixedList<label, 3> permutation(label(0));
  label t = transformIndex;
  if (nIndependentTransforms() > 0)
  {
    permutation[0] = (t%3)-1;
    if (nIndependentTransforms() > 1)
    {
      t /= 3;
      permutation[1] = (t%3)-1;
      if (nIndependentTransforms() > 2)
      {
        t /= 3;
        permutation[2] = (t%3)-1;
      }
    }
  }
#ifdef FULLDEBUG
  t /= 3;
  if (t != 0)
  {
    FATAL_ERROR_IN
    (
      "globalIndexAndTransform::decodeTransformIndex(const label)"
    )
    << "transformIndex : " << transformIndex
    << " has more than 3 fields."
    << abort(FatalError);
  }
#endif
  return permutation;
}
mousse::label mousse::globalIndexAndTransform::addToTransformIndex
(
  const label transformIndex,
  const label patchI,
  const bool isSendingSide,
  const scalar tol
) const
{
  const Pair<label>& transSign = patchTransformSign_[patchI];
  label matchTransI = transSign.first();
  // Hardcoded for max 3 transforms only!
  if (matchTransI > -1 && matchTransI < 3)
  {
    FixedList<label, 3> permutation = decodeTransformIndex(transformIndex);
    // Add patch transform
    // ~~~~~~~~~~~~~~~~~~~
    label sign = transSign.second();
    if (!isSendingSide)
    {
      sign = -sign;
    }
    // If this transform been found already by a patch?
    if (permutation[matchTransI] != 0)
    {
      if (sign == 0)
      {
        // sent from patch without a transformation. Do nothing.
        FATAL_ERROR_IN("globalIndexAndTransform::addToTransformIndex(..)")
          << "patch:" << mesh_.boundaryMesh()[patchI].name()
          << " transform:" << matchTransI << " sign:" << sign
          << "  current transforms:" << permutation
          << exit(FatalError);
      }
      else if (sign == permutation[matchTransI])
      {
        // This is usually illegal. The only exception is for points
        // on the axis of a 180 degree cyclic wedge when the
        // transformation is going to be (-1 0 0 0 -1 0 0 0 +1)
        // (or a different permutation but always two times -1 and
        // once +1)
        bool antiCyclic = false;
        const vectorTensorTransform& vt = transforms_[matchTransI];
        if (mag(vt.t()) < SMALL && vt.hasR())
        {
          const tensor& R = vt.R();
          scalar sumDiag = tr(R);
          scalar sumMagDiag = mag(R.xx())+mag(R.yy())+mag(R.zz());
          if (mag(sumMagDiag-3) < tol && mag(sumDiag+1) < tol)
          {
            antiCyclic = true;
          }
        }
        if (antiCyclic)
        {
          // 180 degree rotational. Reset transformation.
          permutation[matchTransI] = 0;
        }
        else
        {
          FATAL_ERROR_IN
          (
            "mousse::label "
            "mousse::globalIndexAndTransform::addToTransformIndex\n"
            "(\n"
              "const label,\n"
              "const label,\n"
              "const bool\n"
            ") const\n"
          )
          << "More than one patch accessing the same transform "
          << "but not of the same sign." << endl
          << "patch:" << mesh_.boundaryMesh()[patchI].name()
          << " transform:" << matchTransI << " sign:" << sign
          << "  current transforms:" << permutation
          << exit(FatalError);
        }
      }
      else
      {
        permutation[matchTransI] = 0;
      }
    }
    else
    {
      permutation[matchTransI] = sign;
    }
    // Re-encode permutation
    // ~~~~~~~~~~~~~~~~~~~~~
    return encodeTransformIndex(permutation);
  }
  else
  {
    return transformIndex;
  }
}
mousse::label mousse::globalIndexAndTransform::minimumTransformIndex
(
  const label transformIndex0,
  const label transformIndex1
) const
{
  if (transformIndex0 == transformIndex1)
  {
    return transformIndex0;
  }
  // Count number of transforms
  FixedList<label, 3> permutation0 = decodeTransformIndex(transformIndex0);
  label n0 = 0;
  FOR_ALL(permutation0, i)
  {
    if (permutation0[i] != 0)
    {
      n0++;
    }
  }
  FixedList<label, 3> permutation1 = decodeTransformIndex(transformIndex1);
  label n1 = 0;
  FOR_ALL(permutation1, i)
  {
    if (permutation1[i] != 0)
    {
      n1++;
    }
  }
  if (n0 <= n1)
  {
    return transformIndex0;
  }
  else
  {
    return transformIndex1;
  }
}
mousse::label mousse::globalIndexAndTransform::subtractTransformIndex
(
  const label transformIndex0,
  const label transformIndex1
) const
{
  FixedList<label, 3> permutation0 = decodeTransformIndex(transformIndex0);
  FixedList<label, 3> permutation1 = decodeTransformIndex(transformIndex1);
  FOR_ALL(permutation0, i)
  {
    permutation0[i] -= permutation1[i];
  }
  return encodeTransformIndex(permutation0);
}
mousse::labelPair mousse::globalIndexAndTransform::encode
(
  const label index,
  const label transformIndex
)
{
  return encode(Pstream::myProcNo(), index, transformIndex);
}
mousse::labelPair mousse::globalIndexAndTransform::encode
(
  const label procI,
  const label index,
  const label transformIndex
)
{
  if (transformIndex < 0 || transformIndex >= base_)
  {
    FATAL_ERROR_IN
    (
      "mousse::labelPair mousse::globalIndexAndTransform::encode"
      "("
        "const label procI, "
        "const label index, "
        "const label transformIndex"
      ")"
    )
    << "TransformIndex " << transformIndex
    << " is outside allowed range of 0 to "
    << base_ - 1
    << abort(FatalError);
  }
  if (procI > labelMax/base_)
  {
    FATAL_ERROR_IN
    (
      "mousse::labelPair mousse::globalIndexAndTransform::encode"
      "("
        "const label procI, "
        "const label index, "
        "const label transformIndex"
      ")"
    )
    << "Overflow : encoding processor " << procI << " in base " << base_
    << " exceeds capability of label (" << labelMax
    << "). Please recompile with larger datatype for label."
    << exit(FatalError);
  }
  return labelPair
  (
    index,
    transformIndex + procI*base_
  );
}
mousse::label mousse::globalIndexAndTransform::index
(
  const labelPair& globalIAndTransform
)
{
  return globalIAndTransform.first();
}
mousse::label mousse::globalIndexAndTransform::processor
(
  const labelPair& globalIAndTransform
)
{
  return globalIAndTransform.second()/base_;
}
mousse::label mousse::globalIndexAndTransform::transformIndex
(
  const labelPair& globalIAndTransform
)
{
  return globalIAndTransform.second() % base_;
}
mousse::label mousse::globalIndexAndTransform::nIndependentTransforms() const
{
  return transforms_.size();
}
const mousse::List<mousse::vectorTensorTransform>&
mousse::globalIndexAndTransform::transforms() const
{
  return transforms_;
}
const mousse::List<mousse::vectorTensorTransform>&
mousse::globalIndexAndTransform::transformPermutations() const
{
  return transformPermutations_;
}
mousse::label mousse::globalIndexAndTransform::nullTransformIndex() const
{
  return nullTransformIndex_;
}
const mousse::List<mousse::Pair<mousse::label> >&
mousse::globalIndexAndTransform::patchTransformSign() const
{
  return patchTransformSign_;
}
const mousse::vectorTensorTransform& mousse::globalIndexAndTransform::transform
(
  label transformIndex
) const
{
  return transformPermutations_[transformIndex];
}
mousse::labelList mousse::globalIndexAndTransform::transformIndicesForPatches
(
  const labelHashSet& patchIs
) const
{
  List<label> permutation(transforms_.size(), 0);
  labelList selectedTransformIs(0);
  if (patchIs.empty() || transforms_.empty())
  {
    return selectedTransformIs;
  }
  FOR_ALL_CONST_ITER(labelHashSet, patchIs, iter)
  {
    label patchI = iter.key();
    const Pair<label>& transSign = patchTransformSign_[patchI];
    label matchTransI = transSign.first();
    if (matchTransI > -1)
    {
      label sign = transSign.second();
      // If this transform been found already by a patch?
      if (permutation[matchTransI] != 0)
      {
        // If so, if they have opposite signs, then this is
        // considered an error.  They are allowed to be the
        // same sign, but this only results in a single
        // transform.
        if (permutation[matchTransI] != sign)
        {
          FATAL_ERROR_IN
          (
            "const mousse::List<mousse::vectorTensorTransform>& "
            "mousse::globalIndexAndTransform::transformsForPatches"
            "("
              "const labelList& patchIs"
            ") const"
          )
            << "More than one patch accessing the same transform "
            << "but not of the same sign."
            << exit(FatalError);
        }
      }
      else
      {
        permutation[matchTransI] = sign;
      }
    }
  }
  label nUsedTrans = round(sum(mag(permutation)));
  if (nUsedTrans == 0)
  {
    return selectedTransformIs;
  }
  // Number of selected transformations
  label nSelTrans = pow(label(2), nUsedTrans) - 1;
  // Pout<< nl << permutation << nl << endl;
  selectedTransformIs.setSize(nSelTrans);
  switch (nUsedTrans)
  {
    case 1:
    {
      selectedTransformIs[0] = encodeTransformIndex(permutation);
      break;
    }
    case 2:
    {
      List<label> tempPermutation = permutation;
      label a = 0;
      label b = 1;
      // When there are two selected transforms out of three, we
      // need to choose which of them are being permuted
      if (transforms_.size() > nUsedTrans)
      {
        if (permutation[0] == 0)
        {
          a = 1;
          b = 2;
        }
        else if (permutation[1] == 0)
        {
          a = 0;
          b = 2;
        }
        else if (permutation[2] == 0)
        {
          a = 0;
          b = 1;
        }
      }
      tempPermutation[a] = a;
      tempPermutation[b] = permutation[b];
      selectedTransformIs[0] = encodeTransformIndex(tempPermutation);
      tempPermutation[a] = permutation[a];
      tempPermutation[b] = a;
      selectedTransformIs[1] = encodeTransformIndex(tempPermutation);
      tempPermutation[a] = permutation[a];
      tempPermutation[b] = permutation[b];
      selectedTransformIs[2] = encodeTransformIndex(tempPermutation);
      break;
    }
    case 3:
    {
      List<label> tempPermutation = permutation;
      tempPermutation[0] = 0;
      tempPermutation[1] = 0;
      tempPermutation[2] = permutation[2];
      selectedTransformIs[0] = encodeTransformIndex(tempPermutation);
      tempPermutation[0] = 0;
      tempPermutation[1] = permutation[1];
      tempPermutation[2] = 0;
      selectedTransformIs[1] = encodeTransformIndex(tempPermutation);
      tempPermutation[0] = 0;
      tempPermutation[1] = permutation[1];
      tempPermutation[2] = permutation[2];
      selectedTransformIs[2] = encodeTransformIndex(tempPermutation);
      tempPermutation[0] = permutation[0];
      tempPermutation[1] = 0;
      tempPermutation[2] = 0;
      selectedTransformIs[3] = encodeTransformIndex(tempPermutation);
      tempPermutation[0] = permutation[0];
      tempPermutation[1] = 0;
      tempPermutation[2] = permutation[2];
      selectedTransformIs[4] = encodeTransformIndex(tempPermutation);
      tempPermutation[0] = permutation[0];
      tempPermutation[1] = permutation[1];
      tempPermutation[2] = 0;
      selectedTransformIs[5] = encodeTransformIndex(tempPermutation);
      tempPermutation[0] = permutation[0];
      tempPermutation[1] = permutation[1];
      tempPermutation[2] = permutation[2];
      selectedTransformIs[6] = encodeTransformIndex(tempPermutation);
      break;
    }
    default:
    {
      FATAL_ERROR_IN
      (
        "const mousse::List<mousse::vectorTensorTransform>& "
        "mousse::globalIndexAndTransform::transformsForPatches"
        "("
          "const labelList& patchIs"
        ") const"
      )
        << "Only 1-3 transforms are possible."
        << exit(FatalError);
    }
  }
  return selectedTransformIs;
}
mousse::pointField mousse::globalIndexAndTransform::transformPatches
(
  const labelHashSet& patchIs,
  const point& pt
) const
{
  labelList transIs = transformIndicesForPatches(patchIs);
  // Pout<< patchIs << nl << transIs << endl;
  pointField transPts(transIs.size());
  FOR_ALL(transIs, tII)
  {
    transPts[tII] = transformPermutations_[transIs[tII]].transformPosition
    (
      pt
    );
  }
  return transPts;
}
#endif
